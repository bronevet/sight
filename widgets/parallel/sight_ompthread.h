#pragma once
#include <omp.h>
//#include <pthread.h>
#include <string.h>
#undef PUBLIC_API
#include "utils.h"
#include "sight_structure_internal.h"
#include "sight_common.h"
#include "sight_widgets.h"
#include "sight_control.h"
#include "thread_local_storage.h"

namespace sight {
namespace structure {

/**************************************************
 ***** Thread Initialization and Finalization *****
 **************************************************/

class ompthreadThreadInitFinInstantiator: public ThreadInitFinInstantiator 
{

  //public:
  // In many cases we'll want to place the log of each thread or process into a separate 
  // region of output. This is accomplished by creating a comparison object. Logs with
  // comparison objects that have the same IDs are merged with each other and logs with
  // different IDs are kept separate. Multiple comparison objects may be nested to enable
  // threads to be nested within their processes and hierarchical logs, like those produced
  // by Containment Domains.
  // During initialization various code components may register the IDs of all the 
  // comparison tags that should be wrap the entire log generated by each thread. This is done
  // by appending pair <label, ID> that identifies the type of ID to the tail of the 
  // globalComparisonIDs list.
  //ThreadLocalStorageList<std::pair<std::string, std::string> > globalComparisonIDs;
  // Pointers to the comparison objects created for each entry in globalComparisonIDs 
  // are stored globalComparisons
  //static ThreadLocalStorage0<comparison*> globalComparisons;
  //ThreadLocalStorageList<modularApp*> globalModularApps;
  public:
  ompthreadThreadInitFinInstantiator();
  
  static void initialize();
  static void finalize();
};
extern ompthreadThreadInitFinInstantiator ompthreadThreadInitFinInstance;

/********************************
 ***** causalityOMP Management *****
 ********************************/

// Updates the causalityOMP info from the sender side
// Returns the error code of the pthreads functions called.
// cmHeld - indicates whether the causalityOMPMutex is already being held by the calling thread
// If clock!=NULL, it is set to the causal time immediately after the send operation
void sendcausalityOMP(const std::string& sendID, const std::string& recvID, 
                  const std::string& label,
                  bool cmHeld, long long* clock=NULL);
void sendcausalityOMP(const std::string& sendID,
                  const std::string& label,
                  bool cmHeld=false);

// Updates the causalityOMP info on the receiver side
// Returns the error code of the pthreads functions called.
// cmHeld - indicates whether the causalityOMPMutex is already being held by the calling thread
void receivecausalityOMP(const std::string& sendID, int sender,
                     const std::string& recvID, 
                     const std::string& label,
                     bool cmHeld=false);
void receivecausalityOMP(const std::string& sendID, long long senderTime,
                     const std::string& recvID, 
                     const std::string& label,
                     bool cmHeld=false);

// Makes sure that causalityOMP[] is initialized.
// cmHeld - indicates whether the causalityOMPMutex is already being held by the calling thread
void checkcausalityOMP(bool cmHeld);

/**********************************
 ***** OpenMP Thread Creation *****
 **********************************/

void sightOMPThreadInitializer();
void ompthreadCleanup(void * arg);
void sight_ompthread_create();
void sight_ompthread_exit(void *value_ptr);
void sight_ompthread_join(int tid);

/*****************
 **** OMP Lock ***
 *****************/

typedef struct {
  int numLockOwners;
  int lastLockOwner;
  omp_lock_t ompLock;
} sight_omp_lock_t;

void sight_omp_lock_init(sight_omp_lock_t *slock);
void sight_omp_lock_destroy(sight_omp_lock_t *slock);
void sight_omp_lock(sight_omp_lock_t* slock);
void sight_omp_unlock(sight_omp_lock_t* slock);

void sight_omp_receive_single(int singleThread);
void sight_omp_send_single(int ite);


/*******************
 *** OMP Barrier ***
 *******************/

typedef struct {
  int count; // counts the number of times this barrier has been reached
  long long maxTime; // The maximum causal time reached during the most recent barrier
} sight_omp_barrier_t;


void sight_omp_barrier_init(sight_omp_barrier_t* sbar);
void sight_omp_barrier_wait(sight_omp_barrier_t* sbar);

}; // namespace structure 
}; // namespace sight
